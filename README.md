# üìà Stock Recommender App

Una aplicaci√≥n simple construida con Go, Vue y CockroachDB que permite obtener, almacenar y visualizar recomendaciones de acciones de bolsa. Implementa un sistema de recomendaci√≥n basado en reglas para sugerir las mejores acciones en las que invertir hoy.

<div style="display: flex; gap: 16px; flex-wrap: wrap;">
    <img src="./docs/images/Recommendations.png" alt="Screenshot of recommendations view" style="max-width: 48%; height: auto; border: 1px solid #ddd; border-radius: 4px;">
    <img src="./docs/images/homeView.png" alt="Screenshot of home view" style="max-width: 48%; height: auto; border: 1px solid #ddd; border-radius: 4px;">
</div>

---

## üöÄ Caracter√≠sticas

- ETL autom√°tico desde una API externa con paginaci√≥n.
- Backend en Go con endpoints RESTful.
- Base de datos relacional (CockroachDB).
- Frontend en Vue.js para b√∫squeda, filtrado y visualizaci√≥n.
- Algoritmo de recomendaci√≥n de acciones basado en potencial de ganancia, acci√≥n del br√≥ker, cambio de rating y actualidad.

---

## üõ†Ô∏è Tecnolog√≠as

- **Backend:** Go + Chi + CockroachDB
- **Frontend:** Vue.js + Pinia + Tailwind CSS
- **Base de datos:** CockroachDB

---

## üß™ Requisitos

- Go ‚â• 1.19
- Docker (para correr CockroachDB localmente)
- curl o Postman para probar la API
- Node.js ‚â• 16 (para el frontend, si aplica)

---

## Requerimientos: Como fueron resueltos y sus retos

### ‚öôÔ∏è Parte 1: Implementaci√≥n del Proceso ETL (_Connect to the API and store the data_)

Para resolver el requerimiento de descargar la informaci√≥n de stocks del api externa proporcionada que implica un proceso de **_Extraer, Transformar y Cargar (ETL)_** datos desde una API externa hacia una base de datos en la nube (CockroachDB), se desarroll√≥ un proceso autom√°tico en Go que ejecuta los siguientes pasos:

#### **_‚úÖ Extracci√≥n_**

Se consume una API que retorna informaci√≥n de acciones de manera paginada. Para cada p√°gina, se realiza una solicitud `GET` autenticada. El resultado se deserializa en estructuras tipo `APIRawItem`.

- **_Reto_**: La API no siempre responde con datos consistentes. En ocasiones, ciertos campos vienen vac√≠os o mal formateados. Para solucionarlo, se agregaron validaciones robustas antes de transformar los datos.

#### **_üîÑ Transformaci√≥n_**

Cada item recibido se transforma en un objeto Stock, validando campos obligatorios (ticker, time) y convirtiendo strings num√©ricos con s√≠mbolos como `$` y , a `float64`. Tambi√©n se descartan registros con valores inv√°lidos en campos como `rating_from` o `rating_to`, que podr√≠an sesgar an√°lisis posteriores.

- **_Reto_**: Algunos registros ven√≠an con ratings vac√≠os o inconsistentes. Decid√≠ ignorarlos durante la transformaci√≥n y registrar estos fallos en una tabla aparte (failed_items), para poder analizarlos sin afectar la calidad del dataset principal.

#### **_üíæ Carga_**

Una vez transformado el dato, se inserta en la tabla stocks. Se utiliza la estrategia ON CONFLICT DO NOTHING para evitar duplicados basados en la clave (`ticker`, `time`).

- **_Reto_**: A pesar de las validaciones, podr√≠an presentarse errores al insertar (por ejemplo, por campos nulos no controlados). En ese caso, tambi√©n se guarda el item fallido junto con el mensaje de error en la tabla `failed_items`.

#### **_üßæ Registro de errores_**

Para asegurar la trazabilidad, todo el proceso genera logs en archivos con timestamps, ubicados en una carpeta `logs/`. Adem√°s, se implement√≥ una tabla en la base de datos para guardar los registros que fallaron en las fases de transformaci√≥n o carga, con sus respectivos mensajes de error y la fase en la que ocurri√≥ el problema.

---

### üõ†Ô∏è Parte 2.1: API RESTful

Una vez los datos fueron almacenados correctamente en la base de datos, el siguiente paso fue crear una **API RESTful** para exponer esta informaci√≥n a trav√©s de endpoints organizados, seguros y bien estructurados.

#### **_üîå Endpoints Implementados_**

Se definieron 3 endpoints que permiten consultar informaci√≥n de acciones almacenadas:

##### üîç `GET /stocks`

```shell
curl "http://localhost:8080/stocks?search=pharma&sort_by=target_to&order=desc&page=1&limit=10"
```

response:

```json
{
  "items": [
    {
      "ticker": "REGN",
      "company": "Regeneron Pharmaceuticals",
      "brokerage": "BMO Capital Markets",
      "action": "target lowered by",
      "rating_from": "Outperform",
      "rating_to": "Outperform",
      "target_from": 800,
      "target_to": 600,
      "time": "2025-06-03T00:30:05.843101Z"
    }
    // etc...
  ],
  "limit": 10,
  "page": 1,
  "total": 83,
  "totalPages": 9
}
```

##### ‚≠ê `GET /stocks/recommendations`

Devuelve las mejores acciones para invertir hoy seg√∫n el algoritmo.

```shell
curl http://localhost:8080/stocks/recommendations
```

response

```json
[
  {
    "ticker": "SPXC",
    "company": "SPX Technologies",
    "brokerage": "UBS Group",
    "action": "upgraded by",
    "rating_from": "Neutral",
    "rating_to": "Buy",
    "target_from": 160,
    "target_to": 182,
    "time": "2025-06-03T00:30:06.138894Z",
    "Score": 14.4375
  },
  {
    "ticker": "PATH",
    "company": "UiPath",
    "brokerage": "Morgan Stanley",
    "action": "target raised by",
    "rating_from": "Equal Weight",
    "rating_to": "Equal Weight",
    "target_from": 12,
    "target_to": 15,
    "time": "2025-06-03T00:30:06.134828Z",
    "Score": 8.25
  }
  // etc...
]
```

##### üìå `GET /stocks/:ticker`

Devuelve detalles de una acci√≥n espec√≠fica.

```shell
curl "http://localhost:8080/stocks/AKBA"
```

response:

```json
{
  "ticker": "AKBA",
  "company": "Akebia Therapeutics",
  "brokerage": "Leerink Partners",
  "action": "initiated by",
  "rating_from": "Outperform",
  "rating_to": "Outperform",
  "target_from": 7,
  "target_to": 7,
  "time": "2025-04-29T00:30:06.253903Z"
}
```

#### üß± Organizaci√≥n: Handler, Service y Repository

Se sigui√≥ una arquitectura de 3 capas:

```
handler.go  ‚ü∂  service.go  ‚ü∂  repository_interface.go  ‚ü∂  repository_cockroachdb.go
```

- handler.go: expone los endpoints HTTP y maneja par√°metros de la petici√≥n.
- service.go: contiene la l√≥gica de negocio (ej. c√°lculo del puntaje).
- repository_interface.go: define las operaciones esperadas sobre los datos.
- repository_cockroachdb.go: implementaci√≥n de las operaciones usando SQL con pgx.

üß© Ventaja: esta separaci√≥n facilita testeo, mantenimiento y futura migraci√≥n de la capa de datos.

---

### üõ†Ô∏è Parte 2.2: Frontend

El frontend fue desarrollado en Vue 3 con TypeScript, siguiendo buenas pr√°cticas como el uso de la API de composici√≥n, componentes modulares y separaci√≥n clara entre vistas, componentes y l√≥gica de estado.

Se utiliz√≥ Pinia para el manejo del estado global, especialmente para:

- Cachear peticiones a la API (evitando llamadas innecesarias).
- Almacenar filtros de b√∫squeda como el score m√≠nimo y el l√≠mite de resultados.
- Gestionar tablas y estad√≠sticas derivadas (top 3 recomendaciones, promedio, distribuci√≥n, etc.).

Gracias a Pinia y la reactividad de Vue, el sistema actualiza autom√°ticamente los datos al modificar los filtros, mejorando la experiencia del usuario.

- Adem√°s, se aplicaron buenas pr√°cticas como:
- Organizaci√≥n por carpetas (components, stores, models, views).
- Componentes reutilizables y tipados.
- Uso de Tailwind CSS para un dise√±o responsivo y limpio.
- Integraci√≥n eficiente con el backend mediante variables de entorno y peticiones din√°micas.

<!--
- posibles mejoras si la app escala
TODO: expliaci√≥n de como funciona el algoritmo y posibles mejores
- Arquitectura de eventos, como se podr√≠a escalar este sistema para trabajar con datos "vivos" cron-jobs, lambdas, microservicios, colas


TODO: despliegue con terraform
TODO: tests e2e y algunos tests


TODO: explicar como se maneja todo el SDLC (testing, ci, deploy etc...), herramietnas de desarrollo: linters, format, testing, git-hooks, pipelines
---

TODO: Get started variable de entorno etc.
 -->

<!--
TODO: incluir im√°genes de la app funcionando
TODO: script o docker-compose para levantar toda el app por primera vez

-->

---

### üß† Parte 3: Algoritmo de recomendaci√≥n (C√°lculo del Score)

Se implement√≥ un **algoritmo de scoring** que eval√∫a cada registro de la base de datos y le asigna un puntaje num√©rico basado en m√∫ltiples factores relevantes para la toma de decisiones de inversi√≥n.

El objetivo es priorizar aquellas acciones con mayor potencial y menor riesgo, seg√∫n la informaci√≥n disponible.

#### **¬øC√≥mo funciona el algoritmo de score?**

El algoritmo toma en cuenta los siguientes aspectos para cada acci√≥n:

1. **Potencial de ganancia (`target_from` vs `target_to`):**

   - Calcula el porcentaje de ganancia potencial entre el precio objetivo anterior y el nuevo.
   - Si el potencial es positivo, suma m√°s puntos (m√°s peso si la subida es grande).
   - Si es negativo, penaliza el score (pero con menor peso).

2. **Acci√≥n recomendada por el br√≥ker (`action`):**

   - Acciones como "upgraded", "initiated", "target raised" suman puntos.
   - Acciones como "downgraded" o "target lowered" restan puntos.
   - Se utiliza una tabla de palabras clave y su peso relativo.

3. **Cambio de rating (`rating_from` y `rating_to`):**

   - Se asigna un valor num√©rico a cada rating (por ejemplo, "Strong Buy" = 10, "Sell" = 1).
   - Si el rating mejora, se suman puntos proporcionales al cambio.
   - Si el rating empeora, se penaliza el score.

4. **Actualidad de la recomendaci√≥n (`time`):**
   - Las recomendaciones m√°s recientes reciben un bono extra.
   - Si la recomendaci√≥n es del mismo d√≠a, suma m√°s puntos; si es de la √∫ltima semana, suma menos.

#### **Ejemplo de f√≥rmula simplificada:**

```go
score := 0.0
// 1. Potencial de ganancia
if s.TargetFrom > 0 {
    potential := ((s.TargetTo - s.TargetFrom) / s.TargetFrom) * 100
    if potential > 0 {
        score += potential / 4
    } else {
        score += potential / 10
    }
}
// 2. Acci√≥n recomendada
// ... (ver tabla de acciones y pesos)
// 3. Cambio de rating
// ... (ver tabla de ratings y pesos)
// 4. Actualidad
// ... (bono por fecha reciente)
```

#### **Ventajas del enfoque:**

- Permite comparar acciones de diferentes sectores y precios en una misma escala.
- Es flexible: se pueden ajustar los pesos seg√∫n la experiencia o feedback de usuarios.
- Facilita la visualizaci√≥n y el ranking de las mejores oportunidades de inversi√≥n.

#### **Notas adicionales:**

- El score se calcula autom√°ticamente durante el proceso ETL y se almacena en la base de datos para eficiencia.
- El endpoint `/stocks/recommendations` filtra por un score m√≠nimo y ordena por el score m√°s alto, devolviendo las mejores opciones para invertir hoy.

---
